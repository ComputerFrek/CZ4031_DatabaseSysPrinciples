from PyQt5 import uic
from PyQt5.QtWidgets import *


# from qt_material import apply_stylesheet

class demo(QMainWindow):
    def __init__(self):
        super(demo, self).__init__()
        # load UI from file (generated by Qt Designer
        uic.loadUi("demoUI.ui", self)

        # link to UI widgets
        self.in_query = self.findChild(QTextEdit, "in_query")
        self.out_query = self.findChild(QLabel, "out_query")
        self.btn_exec = self.findChild(QPushButton, "btn_exec")
        self.btn_clear = self.findChild(QPushButton, "btn_clear")
        
        self.list_database = self.findChild(QComboBox, "combo_databases")
      
        # # init widgets
        # self.tree_attrs.setHeaderLabels(["Schema"])
        self.btn_clear.clicked.connect(self.clear)

        self.list_database.currentIndexChanged.connect(self._onDatabaseChanged)
        # self.tree_attrs.itemDoubleClicked.connect(self._onSchemaItemDoubleClicked)

    def populateDbTablesInTab(self):
        self.parentTab = self.findChild(QTabWidget, "tabWidget")
        self.parentTab.tabBarClicked.connect(self._tabOnClick)

        # fruits = ["apple", "banana", "cherry","apple", "banana", "cherry", "banana", "cherry"]
        fruits = ["apple", "banana"]

        for index, item in enumerate(fruits):
            print(index)
            self.curTab = self.AddNewTab(item) #each db table

            # if(index == 0):
            #     print("pre-load info")
            # else:
            #     print("dont load info")

        # for table in schema:
        #     table_i = self.AddNewTab(self.parentTab,x)
        #     self.AddListWidget()
        #     for attr in schema[table]:
        #         attr_item = QTreeWidgetItem([attr])
        #         table_i.addChild(attr_item)
    
    
    def AddNewTab(self,tabname):
        """
        Adding Db Table name using this function.
        tabname: using Table name
        """

        newTab = QWidget()
        newTab.layout = QVBoxLayout()

        listCntr = QListWidget()

        for attr in self.schema[tabname]:
            listCntr.addItem(attr) #adding each table's column to QListWidget
        
        newTab.layout.addWidget(listCntr)
        newTab.setLayout(newTab.layout)
        self.parentTab.addTab(newTab,tabname) #adding new tab to Tab List

    def _tabOnClick(self,index):
        self.parentTab.setCurrentIndex(index)

    def showError(self, errMessage, execption=None):
        msgBox = QMessageBox()
        msgBox.setWindowTitle("Exception Details")
        msgBox.setStyleSheet("QLabel{min-width: 450px;min-hight: 550px;}");

        msgBox.setText(errMessage)
        msgBox.setInformativeText("This is additional information")
        if execption is not None:
            msgBox.setDetailedText(str(execption))
        msgBox.setStandardButtons(QMessageBox.Ok)
        msgBox.exec_()

    def clear(self):
        self.clearInputQuery()
        self.clearQEPQuery()

    def clearInputQuery(self):
        self.in_query.setPlainText("")

    def clearQEPQuery(self):
        self.out_query.setText("")

    def readInput(self):
        return self.in_query.toPlainText()

    def setInput(self, text):
        self.in_query.setPlainText(text)

    def setResult(self, text):
        self.out_query.setText(text)

    def setSchema(self, schema=None):
        #self.tree_attrs.clear()
        if schema is None:
            return
        #self.populateDbTablesInTab()

        self.parentTab = self.findChild(QTabWidget, "tabWidget")
        self.parentTab.tabBarClicked.connect(self._tabOnClick)

        self.schema = schema #set this for easily reference
        for table in self.schema:
            self.AddNewTab(table) #each db table

    # callback setter
    def setOnAnalyseClicked(self, callback):
        if callback:
            self.btn_exec.clicked.connect(callback)

    def setOnDatabaseChanged(self, callback):
        self.cb_db_changed = callback

    def setListDatabase(self, list_db=["TPC-H"]):
        self.list_database.clear()
        self.list_database.addItems(list_db)

    # private events handling
    def _onDatabaseChanged(self, cur_index):
        if hasattr(self, "cb_db_changed"):
            self.cb_db_changed()




